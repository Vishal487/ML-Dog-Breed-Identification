# -*- coding: utf-8 -*-
"""Dog-vision.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14jp8HNbAhBf-tX1jNi0sCWsQiJ49N-02

![image.png](data:image/png;base64,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)
"""

import tensorflow as tf
import tensorflow_hub as hub

# check versions
print('TF version: ', tf.__version__)
print('TF HUB version: ',hub.__version__)

# check for GPU availability
print('GPU', 'available' if tf.config.list_physical_devices('GPU') else 'not available :(')

# checkout the labels of our data

import pandas as pd
labels_csv = pd.read_csv('drive/My Drive/Dog Vision/dog breed identification/labels.csv')
labels_csv.head()

labels_csv.describe()

labels_csv['breed'].value_counts().plot.bar(figsize=(20,10));

from IPython.display import display, Image

filenames = ['drive/My Drive/Dog Vision/dog breed identification/train/' + fname + '.jpg' for fname in labels_csv['id']]
filenames[:10]



len(filenames),  len(os.listdir('drive/My Drive/Dog Vision/dog breed identification/train/'))

Image(filenames[9000])

"""Now we've got our image filepaths together, let's get the labels.
We'll take them from `labels_csv` and then turn into a `numpy array`
"""

import numpy as np

labels = labels_csv['breed'].to_numpy()

# OR
# labels = np.array(labels)

labels[:10]

if len(labels) == len(filenames):
  print('number of labels matches')
else:
  print('labels do not matches')

"""Now we have to convert into numbers.
Making a boolean array
"""

unique_breeds = np.unique(labels)
len(unique_breeds)

print(labels[0])
labels[0] == unique_breeds      # this is how we're going to make boolean array

boolean_labels = [label == np.array(unique_breeds) for label in labels]
boolean_labels[:2]

# example : turninig a boolean array into integers

print(labels[0])  # original label
print(np.where(unique_breeds == labels[0])[0][0])      # index where labels occur
print(boolean_labels[0].argmax())       # index where label occur in boolean array
print(boolean_labels[0].astype(int))  # into integer form

"""## Creating our own validation set"""

# setup X, y variable

X = filenames
y = boolean_labels

# Set number of images to use for experimenting

NUM_IMAGES = 1000 #@param {type:'slider', min:1000, max:10000, step:1000}
NUM_IMAGES

"""Now let's split our data into training and validation sets."""

from sklearn.model_selection import train_test_split

X_train, X_val, y_train, y_val = train_test_split(X[:NUM_IMAGES],
                                                  y[:NUM_IMAGES],
                                                  test_size=0.2,
                                                  random_state=42)
len(X_train), len(y_train), len(X_val), len(y_val)

type(X_train[0])

X_train[:5], y_train[:2]

"""## Preprocessing images (turning images into Tensors)

we need to convert our images from an array to tensors because deep learning model run faster on GPU and tensor allow to do the same.

To preprocess our images into Tensors we're going to write a function which does a few things:

1. Takes an image filename as input.
2. Uses TensorFlow to read the file and save it to a variable, image.
4. Turn our image (a jpeg file) into Tensors.
5. Resize the image to be of shape (224, 224).
6. Return the modified image.
"""

from matplotlib.pyplot import imread
image = imread(filenames[42]) # read an image
image        # here it is array

image.shape

image.shape

import matplotlib.pyplot as plt

plt.imshow(image);

# converting image into tensor

tf.constant(image)         # now it is converted into tensor

#  let's create a function

# define image size
IMG_SIZE = 224

def process_image(image_path, img_size=IMG_SIZE):
  """
  takes an image path and turns it into a Tensors
  """
  # read in image file
  image = tf.io.read_file(image_path) 

  # turn the jpeg image into numerical Tensor with 3 color channels (RGB)
  image = tf.image.decode_jpeg(image, channels=3)

  # convert the color channel values ffrom 0-255 to 0-1 values
  image = tf.image.convert_image_dtype(image, tf.float32)

  # Resize the image to our desired size (224, 224)
  image = tf.image.resize(image, size=[IMG_SIZE, IMG_SIZE])
  
  return image

"""## Creating data batches"""

# create a simple function to return a tuple (image, label)

def get_image_label(image_path, label):
  image = process_image(image_path)
  return image, label

# function for batch

# define batch size (32)
BATCH_SIZE = 32

def create_data_batches(X, y=None, batch_size=BATCH_SIZE, valid_data=False, test_data=False):
  """
  Creates batches of data out of image (X) and label (y) pairs.
  Shuffles the data if it's training data but doesn't shuffle it if it's validation data.
  Also accepts test data as input (no labels).
  """
  if test_data:
    print('creating TEST data batches...')
    data = tf.data.Dataset.from_tensor_slices((tf.constant(X)))    # only filepaths
    data_batch = data.map(process_image).batch(BATCH_SIZE)
    return data_batch

  # if the data is a valid dataset, we don't need to shuffle it
  elif valid_data:
    print('creating VALIDATION data batches...')
    data = tf.data.Dataset.from_tensor_slices((tf.constant(X),  # filepaths
                                               tf.constant(y)))  # labels
    data_batch = data.map(get_image_label).batch(BATCH_SIZE)
    return data_batch

  else:   # if the data is training dataset, we shuffle it
    print('creating TRAINING data batches...')
    data = tf.data.Dataset.from_tensor_slices((tf.constant(X),  # filepaths
                                               tf.constant(y))) # labels
    # suffling 
    data = data.shuffle(buffer_size=len(X))

    # create tuples (image, label)
    data = data.map(get_image_label)

    # turn the data into batches
    data_batch = data.batch(BATCH_SIZE)
  return data_batch

# creating training and validation data batches
train_data = create_data_batches(X_train, y_train)
val_data = create_data_batches(X_val, y_val, valid_data=True)

# check out the different attribute of our data batches
train_data.element_spec, val_data.element_spec

"""## Visualizing data batches"""

import matplotlib.pyplot as plt

# creating a function for viewing images in a data batch
def show_25_images(images, labels):
    """
    Display 25 images from a data batch
    """
    
    plt.figure(figsize=(10,10))
    for i in range(4):
        ax = plt.subplot(2, 2, i+1)
        plt.imshow(images[i])
        plt.title(unique_breeds[labels[i].argmax()])
        plt.axis('off')  # turn grid lines off

"""To make computation efficient, a batch is a tightly wound collection of Tensors.
So to view data in a batch, we've to wind it.
We can do so by calling the `as_numpy_iterator()` method on a data batch.
This will turn our a data batch into something which can be iterated over.

Passing an iterable to `next()` will return the next item in the iterator.

In our case, next will return a batch of 32 images and label pairs.

**Note**: Running the cell below and loading images may take a little while.
"""

# Visualizing training images from the training data batch

train_images, train_labels = next(train_data.as_numpy_iterator())
show_25_images(train_images, train_labels )

# visualizing validation images from the validationa data batch

val_images, val_labels = next(val_data.as_numpy_iterator())
show_25_images(val_images, val_labels)

"""## Building a Model
Before we build a model, there are a few things we need to define:
* The `input shape` (our images shape, in the form of Tensors) to our model.
* The `output shape` (image labels, in the form of Tensors)of our model.
* The `URL` of the model we want to use from TensorFlow Hub- https://tfhub.dev/google/imagenet/mobilenet_v2_130_224/classification/4
"""

# Setup input shape to the model
INPUT_SHAPE = [None, IMG_SIZE, IMG_SIZE, 3]   # batch, height, width, color channels

# Setup output shape of our model
OUTPUT_SHAPE = len(unique_breeds)

# Setup model URL from TensorFlow Hub
MODEL_URL = "https://tfhub.dev/google/imagenet/mobilenet_v2_130_224/classification/4"

"""Now we've got our inputs, outputs and model ready to go. Let's put them together into a `Keras deep learning model`!

Knowing this, let's create a function which do following:
* Takes the input shape, output shape and the model we've chosen as parameter.
* Defines the layer in a Keras model in `sequential` fashion (i.e. do this, then this, then that).
* `Compiles` the model (says how it should be evaluated and improve).
* `Builds` the model (tells the model the input shape it'll be getting.
* Returns the model.

Refer-
https://tfhub.dev/google/imagenet/mobilenet_v2_130_224/classification/4


Which activation? Which loss function?
* Binary Classification (such as cat vs. dag)
   * Activation - Sigmoid
   *  loss - BinaryCrossentopy
* Multi-class classification (e.g. our problem)
   * Activation - Softmax
   * Loss - CategoricalCrossentropy
"""

# Create a function which builds a  Keras model

def create_model(input_shape=INPUT_SHAPE, output_shape=OUTPUT_SHAPE, model_url=MODEL_URL):
    print('Building model with : ', MODEL_URL)

    # setup the model layers
    model = tf.keras.Sequential([
                hub.KerasLayer(MODEL_URL),     # Layer 1 (input layer)
                tf.keras.layers.Dense(units=OUTPUT_SHAPE,
                                      activation='softmax')   # Layer 2 
    ])

    # compile the model
    model.compile(
        loss = tf.keras.losses.CategoricalCrossentropy(),
        optimizer=tf.keras.optimizers.Adam(),
        metrics=['accuracy']
    )

    # build the model
    model.build(INPUT_SHAPE)

    return model

model = create_model()
model.summary()

"""## Creating callbacks 
callbacks are helper functions a model can use during training to do such thing as save its progress, check its progress or stop training early if a model stops improving.

We'll create two callbacks, one for `Tensorboards` which helps track our models progress and another for ealy stopping which prevents our model from tarining for too long.

### TensorBoard Callback

To setup a Tensorboard callback, we need to do 3 things:
1. Load the TensorBoard notebook extension.
2. Create a Tensbard callback which is able to save logs to directory and pass it to our model's `fit()` function.
3. Visualize our models training with the `%tensorboard` magic function (we'll do this after training).

refer- https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/TensorBoard
"""

# Commented out IPython magic to ensure Python compatibility.
# Load TensorBoard notebook extension
# %load_ext tensorboard

import datetime

# create a function to build a tensorboard callback
def create_tensorboard_callback():
    # create a log directory for storing TensorBoard logs
    logdir = os.path.join('drive/My Drive/Dog Vision/dog breed identification/logs',
                          # Make it so the logs get tracked wheneve we run an experiment 
                          datetime.datetime.now().strftime('%Y%m%d-%H%M%S'))
    return tf.keras.callbacks.TensorBoard(logdir)

"""### Early stopping callback
Stop training when a monitored quantity has stopped improving.

refer- https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/EarlyStopping
"""

# Create early stopping callback
early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_accuracy',
                                                  patience=3)

"""## Training a model (on subset of data)
Our first model is only going to train on 1000 images, to make sure that everything is working.
"""

NUM_EPOCHS = 100 #@param {type:"slider", min:10, max:100, step:10}

# check for gpu avilability
print('available' if tf.config.list_physical_devices('GPU') else 'not available')

"""Let's create a function which trains a model.
* Create a model using `create_model()`
* Setup a TensorBoard using `create_tensorboard_callback()`.
* Call the `fit()` method on our model passing it the training data, validation data, no. of epochs to train for and the callbacks we'd like to use.
* Return the model.
"""

# Build a function to train and return a trained model

def train_model():
    """
    train a given model and returns the trained model
    """
    # create a model
    model = create_model()

    # create new TensorBoard session everytime we train a model
    tensorboard = create_tensorboard_callback()

    # Fit the model to the data passing it the callbacks we created
    model.fit(x=train_data,
            epochs=NUM_EPOCHS,
            validation_data=val_data,
            validation_freq=1,
            callbacks=[tensorboard, early_stopping])
    
    # return the fitted model
    return model

"""**Note:** runnin gbelow cell may take long time

Actually first epoch take more time and then after it's quite fast.
"""

model = train_model()

"""**Note:** Overfitting to begin with is a good thing, it means our model is learning something.

**Question:** What are the different ways to prevent model overfitting in deep learning neural networks?

### Checking the TensorBoard logs
Teh Tensorboard magic function (`%tensorboard`) will accesss the logs directory we created earlier and visualize its contents.
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorboard --logdir drive/My\ Drive/Dog\ Vision/dog\ breed\ identification/logs --host=127.0.0.1 --inspect

val_data

predictions = model.predict(val_data, verbose=True)

predictions

predictions.shape

# first prediction

print(predictions[0])
print(f"Max value (probability of prediction): {np.max(predictions[0])}")  # the max pobability value predicted by our model
print(f"Sum: {np.sum(predictions[0])}")  # bcz we used softmax activation this should be close to 1
print(f"Max index: {np.argmax(predictions[0])}")  # the index of where the max. value occur
print(f"Predicted label: {unique_breeds[np.argmax(predictions[0])]}")   # predicted label

"""**Note:** Prediction probabilities are also known as confidence labels.

Let's build a little function to convert prediction probabilities into predicted labels.
"""

def get_pred_label(prediction_probabilities):
    """
    turns an array of prediction probabilities into a label
    """

    return unique_breeds[np.argmax(prediction_probabilities)]

# get a predicted label based on an array of prediction probabilities
pred_label = get_pred_label(predictions[0])
pred_label

"""### Unbatchify

Since our validation data (`val_data`) is in batch form, to get a list of validation images and labels, we'll have to unbatch it (using `unbatch()`) and then turn it into an iterator using `as_numpy_iterator()`.
"""

def unbatchify(data):
    """
    takes a batched dataset of (image, label) Tensors and returns separate
    arrays of image and labels.
    """

    images = []
    labels = []
    # loop through batched data
    for image, label in data.unbatch().as_numpy_iterator():
        images.append(image)
        labels.append(unique_breeds[np.argmax(label)])
    return images, labels

# unbatchify the validation data
val_images, val_labels = unbatchify(val_data)
val_images[0], val_labels[0]

"""Now we've got ways to get:
* Prediction labels
* Validation labels (truth labels)
* validation images

Let's make some function to more visualize.

The function do the following:
* Take an array of prediction probabilities, an array of truth labels, an arrray of images and an integer.
* Convert the prediction probabilities to a predicted label.
* Plot the predicted label, its predicted probability, the truth label and target image on a single plot.
"""

def plot_pred(prediction_probabilities, labels, images, n=1):
    """
    view the prediction, ground truth label and image for sample n
    """

    pred_prob, true_label, image = prediction_probabilities[n], labels[n], images[n]

    # get the predicted label
    pred_label = get_pred_label(pred_prob)

    # plot image 
    plt.imshow(image)
    plt.xticks([])   # remove x ticks
    plt.yticks([])   # remove y ticks

    # change the color of the title depending on whether the prediction is correct
    if pred_label == true_label:
        color = 'green'
    else:
        color = 'red'

    plt.title("{} {:2.0f}% ({})".format(pred_label,
                                        np.max(pred_prob)*100,
                                        true_label),
              color=color)

# view an example prediction, original image and truth label
plot_pred(prediction_probabilities=predictions,
          labels=val_labels,
          images=val_images)

"""Let's see what our model predicted for other breeds instead of just seeing maximum one.

Let's create a function to demonstrate. The function will:
* Take an input of a prediction probabilities array, a ground truth labels array and an integer.
* Find the predicted label using `get_pred_label()`.
* Find the top 10:
  * Prediction probabilities indexes.
  * Prediction probabilities values.
  * Prediction labels.
* Plot the top 10 prediction probabilities values and labels, coloring the true labels green.
"""

def plot_pred_conf(prediction_probabilities, labels, n=1):
    """
    plots the top 10 highest prediction confidence along with the truth label
    for sample n
    """

    pred_prob, true_label = prediction_probabilities[n], labels[n]

    # get the predicted label
    pred_label = get_pred_label(pred_prob)

    # find the top 10 prediction confidences indices
    top_10_pred_indexes = pred_prob.argsort()[-10:][::-1]

    # top 10 values
    top_10_pred_values = pred_prob[top_10_pred_indexes]

    # top 10 prediction labels
    top_10_pred_labels = unique_breeds[top_10_pred_indexes]

    # plotting 
    top_plot = plt.bar(np.arange(len(top_10_pred_labels)),
                       top_10_pred_values,
                       color='grey')
    plt.xticks(np.arange(len(top_10_pred_labels)),
               labels=top_10_pred_labels,
               rotation='vertical')
    
    # change the color of true model
    if np.isin(true_label, top_10_pred_labels):
        top_plot[np.argmax(top_10_pred_labels == true_label)].set_color('green')
    else:
        pass

plot_pred_conf(prediction_probabilities=predictions,
               labels=val_labels,
               n=9)

# Let's plot a few predictions and their different values

i_multiplier = 20
num_rows = 3
num_cols = 2
num_images = num_rows*num_cols
plt.figure(figsize=(5*2*num_cols, 5*num_rows))
for i in range(num_images):
    plt.subplot(num_rows, 2*num_cols, 2*i+1)
    plot_pred(prediction_probabilities=predictions,
              labels=val_labels,
              images=val_images,
              n=i+i_multiplier)
    plt.subplot(num_rows, 2*num_cols, 2*i+2)
    plot_pred_conf(prediction_probabilities=predictions,
                   labels=val_labels,
                   n=i+i_multiplier)
plt.tight_layout(h_pad=1.0)
plt.show()

"""## Saving and reloading a model"""

def save_model(model, suffix=None):     # suffix is just for communicating
    """
    saves a given model in a models directory and apppendsa suffix (a str)
    for clarity
    """
    # create model directory with current time
    modeldir = os.path.join('drive/My Drive/Dog Vision/dog breed identification/models',
                            datetime.datetime.now().strftime('%Y%m%d-%H%M%s'))
    model_path = modeldir + '-' + suffix + '.h5'
    print(f"Saving model to: {model_path}...")
    model.save(model_path)
    return model_path

def load_model(model_path):
    """
    loads a saved model from a specified path.
    """
    print(f'loading saved model from: {model_path}...')
    model = tf.keras.models.load_model(model_path,
                                       custom_objects={'KerasLayer':hub.KerasLayer})
    return model

save_model(model, suffix='1000-images-Adam')

# Load our model trained on 1000 images
model_1000_images = load_model('drive/My Drive/Dog Vision/dog breed identification/models/20200403-15561585929385-1000-images-Adam.h5')

# we can ignore warnings!!!

"""Compare the two models : original one and loaded one"""

model.evaluate(val_data)

model_1000_images.evaluate(val_data)

"""## Training a model (on full data)"""

len(X), len(y)

X[:10]

len(X_train),  len(y_train)

y[:2]

# create a databatch with full dataset
full_data = create_data_batches(X, y)

full_data

# create a model for full dataset

full_model = create_model()

# create full model callbackes

full_model_tensorboard = create_tensorboard_callback()

# no validation set when training on fulll data, so we can't monitor validationaccuracy

full_model_early_stopping = tf.keras.callbacks.EarlyStopping(monitor='accuracy',
                                                             patience=3)

"""**Note:** Running the cell below will take a little while
(maybe `upto 30 minutes` for the first epochs) bcz the GPU we're using in the runtime has to load all of the images into memory.
"""

# fit the full model to the full data
full_model.fit(x=full_data,
               epochs=NUM_EPOCHS,
               callbacks=[full_model_tensorboard, full_model_early_stopping])

full_model.summary()

"""## Save and Reload full model"""

# save our full model

save_model(full_model, suffix='full-model')

# reload saved full model

loaded_full_model = load_model('drive/My Drive/Dog Vision/dog breed identification/models/20200404-06571585983474-full-model.h5')

"""### Making predictions on the test dataset
Since our model has been trained on images in the form of Tensor batches, to make predictions on the test data, we'll have to get it into the same format.

Luckily we created `create_data_batches()` earlier which can take a list of filenames as input and convert them into Tensor batches.

To make predictions on the test data, we'll:

* Get the test image filenames.
* Convert the filenames into test data batches using create_data_batches() and setting the test_data parameter to True (since there are no labels with the test images).
* Make a predictions array by passing the test data batches to the predict() function.
"""

test_path = 'drive/My Drive/Dog Vision/dog breed identification/test/'
test_filenames = [test_path + fname for fname in os.listdir(test_path)]

test_filenames[:10]

len(test_filenames)

# create test data batch

test_data = create_data_batches(test_filenames, test_data=True)

"""**Note:** Since there are 10,000+ test images, making predictions could take a while, even on a GPU. So beware running the cell below may take up to an hour."""

# make predictions on test data batch using the loaded full model

test_predictions = loaded_full_model.predict(test_data,
                                             verbose=1)

test_predictions[:10]

"""Preparing test dataset predictions for Kaggle

It looks like they want the models output probabilities each for label along with the image ID's.

To get the data in this format, we'll:

* Create a pandas DataFrame with an ID column as well as a column for each dog breed.
* Add data to the ID column by extracting the test image ID's from their filepaths.
Add data (the prediction probabilities) to each of the dog breed columns using the unique_breeds list and the test_predictions list.
* Export the DataFrame as a CSV to submit it to Kaggle.
"""

# create pandas dataframe with empty columns

preds_df = pd.DataFrame(columns=['id'] + list(unique_breeds))
preds_df.head()

preds_df.shape

# append test image ID's to prediction DataFrame

test_path = 'drive/My Drive/Dog Vision/dog breed identification/test/'
preds_df['id'] = [os.path.splitext(path)[0] for path in os.listdir(test_path)]
preds_df.head()

# add the prediction probabilities to each dog breed column
preds_df[list(unique_breeds)] = test_predictions
preds_df.head()

preds_df.to_csv('drive/My Drive/Dog Vision/dog breed identification/full_submission_1_mobilenetV2_adan.csv',
                index=False)

"""THANK YOU!!!"""

